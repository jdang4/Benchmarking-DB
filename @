#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <exception>
#include "headers/RedisClient.h"

using namespace sw::redis;
using namespace std;


RedisClient::RedisClient(int n) : DBClient()
{
    entryVal = DBClient::getEntryVal('a');
    newVal = DBClient::getEntryVal('j');
    numOfRuns = n; 
}


RedisClient::~RedisClient() {}


/**
 * see description at DBClient::connect()
 */
void RedisClient::connect()
{
    try {
	redis = new Redis("tcp://redis-master:6379");
	 
	// verifying the connection by sending a command
	redis->set("foo", "bar");


	cout << "CONNECTED TO REDIS!\n" << endl;
    
    } catch (const Error &e) {
	cout << "UNABLE TO CONNECT TO REDIS\n" << endl;
	exit(1);
    }
}


/**
 * see description at DBClient::initializeDB()
 */
double RedisClient::initializeDB() 
{
    double time;
    
    try {

	auto start = chrono::high_resolution_clock::now();

	cout << "Creating the SDB..." << endl;

	redis->command<void>("flushall");

	for (int64_t i = 1; i <= NUM_OF_ENTRIES; i++) 
	{
	    auto key = to_string(i);
	    redis->set(key, entryVal);
	}

	auto end = chrono::high_resolution_clock::now();

	cout << "SDB Creation Completed!\n" << endl;

	time = DBClient::calculateTime(start, end);
	
    } catch (const Error &e) {
	cout << "ERROR DURING INITIALIZATION" << endl;
	time = -1.0;
    }

    return time;
}


template<typename Lambda>
double RedisClient::run_threads(Lambda f, int begin, bool random)
{
    int numOfThreads = 10;
    vector<thread> thread_pool;

    int perThread = numOfRuns / numOfThreads;
    int remainingThreads = numOfRuns % numOfThreads;

    int beginRange, endRange;

    int runningCount = begin;

    auto start = chrono::high_resolution_clock::now();

    for (int i = 0; i < numOfThreads; i++)
    {
        beginRange = runningCount;
        endRange = beginRange + perThread;

        if (remainingThreads > 0)
        {
            remainingThreads--;
            endRange++;
        }

        thread_pool.push_back(thread(f, beginRange, endRange, random));

        runningCount = endRange;
    }

    for (auto &thread : thread_pool)
    {
        thread.join();
    }

    auto end = chrono::high_resolution_clock::now();

    return DBClient::calculateTime(start, end);
}


/**
 * see a description at DBClient::readEntry
 */
double RedisClient::readEntry(string akey)
{
    auto read = [&](int start, int end, bool random) {
        try {
            for (int i = start; i < end; i++)
            {
		srand(time(0));
		int randomNum = (rand() % (end + 1 - start)) + start;  
		int key = (random) ? randomNum : i;

                redis->get(to_string(key));
            }
        
        } catch (const Error &e) {
            cerr << "ERROR DURING READ" << endl;
            exit(-1);
        }
    };
    
    return run_threads(read, 1, false);
}


/**
 * see description at DBClient::insertEntry()
 */
double RedisClient::insertEntry(string key)
{
    auto insert = [&](int start, int end, bool random) {
        try {
            for (int i = start; i < end; i++)
            {
                redis->set(to_string(i), entryVal);
            }
        
        } catch (const Error &e) {
            cerr << "ERROR DURING INSERT" << endl;
            exit(-1);
        }
    };

    return run_threads(insert, 2000000, false);
}

/**
 * see description at DBClient::updateEntry()
 */
double RedisClient::updateEntry(string key) 
{
    auto update = [&](int start, int end, bool random) {
	try {
	    for (int i = start; i < end; i++)
	    {
		srand(time(0));
		int randomNum = (rand() % (end + 1 - start)) + start;  
		int key = (random) ? randomNum : i;

		redis->set(to_string(key), newVal);
	    }
	
	} catch (const Error &e) {
	    cerr << "ERROR DURING UPDATE" << endl;
	    exit(-1);
	}
    };

    return run_threads(update, 2000000, false);
}


/**
 * see description at DBClient::deleteEntry()
 */
double RedisClient::deleteEntry(string key)
{
    auto deletion = [&](int start, int end, bool random) {
	try {
	    for (int i = start; i < end; i++)
	    {
		srand(time(0));
		int randomNum = (rand() % (end + 1 - start)) + start;  
		int key = (random) ? randomNum : i;

		redis->del(to_string(key));
	    }
	
	} catch (const Error &e) {
	    cerr << "ERROR DURING DELETION" << endl;
	    exit(-1);
	}
    };

    return run_threads(deletion, 2000000, false);
}

/*
 * see description at DBClient::simultaneousReaders
 */
double RedisClient::simultaneousReaders(int n, string key)
{
    vector<thread> thread_pool;

    auto read = [&](string aKey)
    {
        readEntry(aKey);
    };

    if (n <= 0)
    {
        return -1.0;
    }

    else if (n == 1)
    {
	    return readEntry(key);
    }

    auto start = chrono::high_resolution_clock::now();

    for (int i = 0; i < n; i++)
    {
	    thread_pool.push_back(thread(read, key));
    }

    for (auto &thread : thread_pool)
    {
	    thread.join();
    }

    auto end = chrono::high_resolution_clock::now();
 
    return DBClient::calculateTime(start, end);

}

/*
 * see description at DBClient::simultaneousTasks()
 */
double RedisClient::simultaneousTasks(int n)
{
    auto read_and_write = [&](int start, int end, bool random) {
	
	auto read = [&](int key) {
	    try {
		redis->get(to_string(key));
	    
	    } catch (const Error &e) {
		cout << "ERROR READING" << endl;
		exit(-1);
	    }
	};

	auto write = [&](int key) {
	    try {
		redis->set(to_string(key), newVal);
	    
	    } catch (const Error &e) {
		cout << "ERROR UPDATING" << endl;
		exit(-1);
	    }
	};

	int halfMark = (end - start) / 2;

	for (int i = start; i < end; i++) 
	{
	    srand(time(0));
	    int randomNum = (rand() % (end + 1 - start)) + start;  
	    int key = (random) ? randomNum : i;

	    if (i < halfMark)
	    {
		read(key);
	    }

	    else
	    {
		write(key);
	    }
	}

    };

    return run_threads(read_and_write, 1, true);
}


/*
 * see description at DBClient::performTransactions()
 */
double RedisClient::performTransactions(int n, double successPercentage)
{
    if (successPercentage < 0 || successPercentage > 100 || n <= 0)
    {
	return -1.0;
    }

    int numOfSuccess = n * successPercentage;

    // defines what the success transaction composes of
    auto success = [&] (string aKey)
    {
	insertEntry(aKey);

	// having simultaneous readers/modifiers for each transaction
	simultaneousTasks(8);

	readEntry(aKey);
	deleteEntry(aKey);
    };

    // defines what the fail transaction composes of
    auto fail = [&] (string aKey)
    {
	insertEntry(aKey);
	deleteEntry(aKey);
    };

    vector<thread> thread_pool;

    int64_t key = 2000000;

    auto start = chrono::high_resolution_clock::now();

    // each thread will either perform a success or a fail transaction
    for (int i = 0; i < n; i++)
    {
	if (i < numOfSuccess)
	{
	    auto aKey = to_string(key);
	    thread_pool.push_back(thread(success, aKey));
	}

	else
	{
	    auto aKey = to_string(key);
	    thread_pool.push_back(thread(fail, aKey));
	}

	key += 1;
    }
    
    for (auto &thread : thread_pool)
    {
	thread.join();
    }
    
    auto end = chrono::high_resolution_clock::now();

    return DBClient::calculateTime(start, end);
}    

